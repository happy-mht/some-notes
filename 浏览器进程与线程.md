# 浏览器的进程和线程

浏览器是多进程的，一般每打开一个tab页，就相当于创建了一个独立的浏览器进程。

**注意**：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）

## 浏览器都包含哪些进程？

1. Browser 进程：浏览器的主进程 
    - 负责浏览器界面显示，与用户交互。如前进，后退等
    - 负责各个页面的管理，创建和销毁其他进程
    - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
    - 网络资源的管理，下载等

2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 。
3. GPU进程：最多一个，用于3D绘制等。 
4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

## 渲染进程（浏览器内核）

> 需要注意浏览器和浏览器内核是不同的概念，浏览器指的是 Chrome、Firefox，而浏览器内核则是 Blink、Gecko，浏览器内核只负责渲染，GUI 及网络连接等跨平台工作则是浏览器实现的

浏览器的渲染进程是多线程的，页面的渲染、JS的执行、事件的循环都在这里进行。

包含线程（常驻线程）：

1. GUI 渲染线程

    负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。

    当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

    注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2. JS引擎线程

    负责解析Javascript脚本，运行代码。JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序

3. 事件触发线程

    - 归属于浏览器而不是JS引擎，用来控制事件循环

    - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中

    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

    - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4. 定时触发器线程

    传说中的 setInternal与 setTimeout所在线程

    浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）

    因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）

    注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

5. 异步http请求线程

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

## 简单梳理下浏览器渲染流程

为了简化理解，前期工作直接省略成：

      浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过 `RendererHost` 接口转交给 `Renderer` 进程

浏览器渲染流程开始,浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

- 解析html建立dom树

- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）

- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

- 绘制render树（paint），绘制页面像素信息

- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

- 所有详细步骤都已经略去，渲染完毕后就是 load事件了，之后就是自己的JS逻辑处理了

